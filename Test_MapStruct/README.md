<h2> MapStruct </h2>
- Java용 코드 생성 매핑 라이브러리 

    - 객체데이터 구조 불일치 문제를 해결하기 위해서 Java코드에서 매핑을 해준다
    - ex) 객체 -> DTO

- MapStruct 사용 방식
  -  MapStruct는 Java코드 생성 매핑 프레임워크(라이브러리)
  - 인터페이스에 매핑규칙(원본 객체의 field를 -> DTO 객체 필드로 옮길지 선언)
  - 매핑 규칙을 지정해주면 Compile 시점에 MapStruct가 실제 매핑코드를 자동으로 생성해준다.
  - 여기서 말하는 실제 매핑코드는 @Mapper 인터페이스의 구현체이다.
  - 이 구현체는 MapStruct가 내부적으로 구현체를 만들어 Mapping을 해준다.

- 장점
  - 보일러 플레이팅 코드를 제거 (Mapping관련)
  - 컴파일 시점에 검증
  - 순수 자바코드로 이루어진 프레임워크리므로 성능이 좋음
  - 컬렉션/중첩필드/리스트를 자동으로 매핑해준다
  - null-safe 코드를 만들어줌

- Spring에서 MapStruct 사용
  - @Mapper(componentModel = "spring") 지정해주면  @Autowired로 DI 가능


<h3> 의문점? </h3>

1. @Mapper를 붙인다고 이 인터페이스를 어떻게 읽는지
2. @Mapping을 인터페이스의 메서드 하나에만 지정했는데 어떻게 다른 메소드 까지 동일하게 동작하는지
3. 메소드 명은 지정이 되어있는지?

<h3> 결과 </h3>

1. 컴파일러 플러그인 이므로 컴파일 시점에서 @Mapper가 붙은 인터페이스 스캔 ->
메소드 분석 후 각 메서드의 (파라미터 타입), 리턴 타입을 보고 매핑 -> 구현 클래스 자동생성
2. 요소 타입(파마미터와 리턴타입)에 맞는 매핑매서드를 찾아서 리스트 매핑 시 내부적으로 로직 자동 수행
   리스트 매핑은 내부적으로 기존 단일 매핑 함수를 재사용함.
3. 매핑 기준으로 구현체를 생성해서 오버라이딩하므로 메서드 명은 아무렇게나 지정해도 됨.

<h3> 해당 기술을 학습 한 이유</h3>

- 직접 매핑을 하면서 불편한 점(코드의 반복 및 헷갈림?)이 한두가지가 아니라서 매핑해주는 라이브러리가 있나 찾아보았다.
- 자동 매핑을해주는여러 기술중 가장 비용이 적고 성능이 좋다고 생각해서 MapStruct를 학습함.